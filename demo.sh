#!/bin/bash

show_cmd () {
  echo
  echo "    \$ $1"
  bash -c "$1" | sed 's/^/    /'
  echo
}
echo 'This README is generated by running `build.sh` and then `demo.sh`'
echo

echo Suppose we have a program, call_write.c, that writes some strings to stdout:
show_cmd "cat ./call_write.c"

echo Output of call_write:
show_cmd "./call_write"

echo Suppose we want to double all output to stdout.
echo All of the functions in call_write ultimately make a write syscall, so we interpose the syscall function directly:
show_cmd "cat ./interpose.c"

echo Unfortunately, it turns out that the libc implementations of these functions make inlined syscalls,
echo so this only successfully interposes on and doubles the actual call to syscall:
show_cmd 'LD_PRELOAD=$PWD/libinterpose.so ./call_write'

echo We can fix this by using a patched libc that replaces inlined syscalls with calls to the syscall function,
echo "and also LD_PRELOAD'ing that. It turns out we primarly just need to"
echo '[redefine some syscall macros](https://github.com/sporksmith/glibc/commit/6d667159940450ba1ce40b5ea00e8a88a4f7fe21).'
echo "When using the library as an LD_PRELOAD I initially got some crashes in code that tries to do a dynamic symbol lookup"
echo "to determine whether it's not the primary libc in use; I worked around by effectively"
echo '[hard-coding the answer to "yes"](https://github.com/sporksmith/glibc/commit/575ea9f2412905a323cd0c3c380f003bb9e61e67)'
echo 
echo "Note that the functions that operate on the stdout file stream actually"
echo "write to an in-memory buffer. A 'write' syscall happens at the end when the whole buffer is flushed."
show_cmd 'LD_PRELOAD=$PWD/libinterpose.so:$PWD/glibc-build/libc.so ./call_write'
